var d=(e,t)=>({token:t,compiled:()=>!0});function R(e,t){let{parseExpression:i=d}=t??{},l=x(e),o={requestDefinition:[],policyDefinition:[],roleDefinition:{},policyEffect:{},matchers:{}};for(let[r,n]of Object.entries(l))for(let a of n){let[p,s]=a.split(/=(.*)/).map((f)=>f.trim());if(!p||!s)continue;let c=r;switch(c){case"requestDefinition":case"policyDefinition":o[c]=m(s);break;case"roleDefinition":o.roleDefinition[p]=y(s);break;case"matchers":case"policyEffect":{let{compiled:f,token:u}=i(s,p,c);o[c][u]=f}break}}return o}function m(e){return e.split(/,\s*/)}function y(e){return e.split(/,\s*/).length}var M=/(?<type>[\w_]+)\](?<expr>[^[]+)/g;function x(e){let t=e.matchAll(M),i={};for(let l of t){let{type:o,expr:r}=l.groups??{};if(!o||!r)continue;i[D(o)]=r.split(`
`).map((n)=>n.trim()).filter((n)=>!!n)}return i}function D(e){return e.replace(/_([a-z])/g,(t,i)=>i.toUpperCase())}export{R as parseModel,d as naiveParser};
export{R as a};
