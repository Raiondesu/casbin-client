class ${add(y,E,M){if(typeof arguments[0]!="string")for(let z in arguments[0])this.add(z,arguments[0][z],arguments[1]);else(Array.isArray(y)?y:[y]).forEach(function(z){if(this[z]=this[z]||[],E)this[z][M?"unshift":"push"](E)},this)}run(y,E){this[y]=this[y]||[],this[y].forEach(function(M){M.call(E&&E.context?E.context:E,E)})}}class D{constructor(y){this.jsep=y,this.registered={}}register(...y){y.forEach((E)=>{if(typeof E!=="object"||!E.name||!E.init)throw Error("Invalid JSEP plugin format");if(this.registered[E.name])return;E.init(this.jsep),this.registered[E.name]=E})}}class R{static get version(){return"1.4.0"}static toString(){return"JavaScript Expression Parser (JSEP) v"+R.version}static addUnaryOp(y){return R.max_unop_len=Math.max(y.length,R.max_unop_len),R.unary_ops[y]=1,R}static addBinaryOp(y,E,M){if(R.max_binop_len=Math.max(y.length,R.max_binop_len),R.binary_ops[y]=E,M)R.right_associative.add(y);else R.right_associative.delete(y);return R}static addIdentifierChar(y){return R.additional_identifier_chars.add(y),R}static addLiteral(y,E){return R.literals[y]=E,R}static removeUnaryOp(y){if(delete R.unary_ops[y],y.length===R.max_unop_len)R.max_unop_len=R.getMaxKeyLen(R.unary_ops);return R}static removeAllUnaryOps(){return R.unary_ops={},R.max_unop_len=0,R}static removeIdentifierChar(y){return R.additional_identifier_chars.delete(y),R}static removeBinaryOp(y){if(delete R.binary_ops[y],y.length===R.max_binop_len)R.max_binop_len=R.getMaxKeyLen(R.binary_ops);return R.right_associative.delete(y),R}static removeAllBinaryOps(){return R.binary_ops={},R.max_binop_len=0,R}static removeLiteral(y){return delete R.literals[y],R}static removeAllLiterals(){return R.literals={},R}get char(){return this.expr.charAt(this.index)}get code(){return this.expr.charCodeAt(this.index)}constructor(y){this.expr=y,this.index=0}static parse(y){return new R(y).parse()}static getMaxKeyLen(y){return Math.max(0,...Object.keys(y).map((E)=>E.length))}static isDecimalDigit(y){return y>=48&&y<=57}static binaryPrecedence(y){return R.binary_ops[y]||0}static isIdentifierStart(y){return y>=65&&y<=90||y>=97&&y<=122||y>=128&&!R.binary_ops[String.fromCharCode(y)]||R.additional_identifier_chars.has(String.fromCharCode(y))}static isIdentifierPart(y){return R.isIdentifierStart(y)||R.isDecimalDigit(y)}throwError(y){let E=Error(y+" at character "+this.index);throw E.index=this.index,E.description=y,E}runHook(y,E){if(R.hooks[y]){let M={context:this,node:E};return R.hooks.run(y,M),M.node}return E}searchHook(y){if(R.hooks[y]){let E={context:this};return R.hooks[y].find(function(M){return M.call(E.context,E),E.node}),E.node}}gobbleSpaces(){let y=this.code;while(y===R.SPACE_CODE||y===R.TAB_CODE||y===R.LF_CODE||y===R.CR_CODE)y=this.expr.charCodeAt(++this.index);this.runHook("gobble-spaces")}parse(){this.runHook("before-all");let y=this.gobbleExpressions(),E=y.length===1?y[0]:{type:R.COMPOUND,body:y};return this.runHook("after-all",E)}gobbleExpressions(y){let E=[],M,z;while(this.index<this.expr.length)if(M=this.code,M===R.SEMCOL_CODE||M===R.COMMA_CODE)this.index++;else if(z=this.gobbleExpression())E.push(z);else if(this.index<this.expr.length){if(M===y)break;this.throwError('Unexpected "'+this.char+'"')}return E}gobbleExpression(){let y=this.searchHook("gobble-expression")||this.gobbleBinaryExpression();return this.gobbleSpaces(),this.runHook("after-expression",y)}gobbleBinaryOp(){this.gobbleSpaces();let y=this.expr.substr(this.index,R.max_binop_len),E=y.length;while(E>0){if(R.binary_ops.hasOwnProperty(y)&&(!R.isIdentifierStart(this.code)||this.index+y.length<this.expr.length&&!R.isIdentifierPart(this.expr.charCodeAt(this.index+y.length))))return this.index+=E,y;y=y.substr(0,--E)}return!1}gobbleBinaryExpression(){let y,E,M,z,F,G,K,Q,S;if(G=this.gobbleToken(),!G)return G;if(E=this.gobbleBinaryOp(),!E)return G;if(F={value:E,prec:R.binaryPrecedence(E),right_a:R.right_associative.has(E)},K=this.gobbleToken(),!K)this.throwError("Expected expression after "+E);z=[G,F,K];while(E=this.gobbleBinaryOp()){if(M=R.binaryPrecedence(E),M===0){this.index-=E.length;break}F={value:E,prec:M,right_a:R.right_associative.has(E)},S=E;let W=(Y)=>F.right_a&&Y.right_a?M>Y.prec:M<=Y.prec;while(z.length>2&&W(z[z.length-2]))K=z.pop(),E=z.pop().value,G=z.pop(),y={type:R.BINARY_EXP,operator:E,left:G,right:K},z.push(y);if(y=this.gobbleToken(),!y)this.throwError("Expected expression after "+S);z.push(F,y)}Q=z.length-1,y=z[Q];while(Q>1)y={type:R.BINARY_EXP,operator:z[Q-1].value,left:z[Q-2],right:y},Q-=2;return y}gobbleToken(){let y,E,M,z;if(this.gobbleSpaces(),z=this.searchHook("gobble-token"),z)return this.runHook("after-token",z);if(y=this.code,R.isDecimalDigit(y)||y===R.PERIOD_CODE)return this.gobbleNumericLiteral();if(y===R.SQUOTE_CODE||y===R.DQUOTE_CODE)z=this.gobbleStringLiteral();else if(y===R.OBRACK_CODE)z=this.gobbleArray();else{E=this.expr.substr(this.index,R.max_unop_len),M=E.length;while(M>0){if(R.unary_ops.hasOwnProperty(E)&&(!R.isIdentifierStart(this.code)||this.index+E.length<this.expr.length&&!R.isIdentifierPart(this.expr.charCodeAt(this.index+E.length)))){this.index+=M;let F=this.gobbleToken();if(!F)this.throwError("missing unaryOp argument");return this.runHook("after-token",{type:R.UNARY_EXP,operator:E,argument:F,prefix:!0})}E=E.substr(0,--M)}if(R.isIdentifierStart(y)){if(z=this.gobbleIdentifier(),R.literals.hasOwnProperty(z.name))z={type:R.LITERAL,value:R.literals[z.name],raw:z.name};else if(z.name===R.this_str)z={type:R.THIS_EXP}}else if(y===R.OPAREN_CODE)z=this.gobbleGroup()}if(!z)return this.runHook("after-token",!1);return z=this.gobbleTokenProperty(z),this.runHook("after-token",z)}gobbleTokenProperty(y){this.gobbleSpaces();let E=this.code;while(E===R.PERIOD_CODE||E===R.OBRACK_CODE||E===R.OPAREN_CODE||E===R.QUMARK_CODE){let M;if(E===R.QUMARK_CODE){if(this.expr.charCodeAt(this.index+1)!==R.PERIOD_CODE)break;M=!0,this.index+=2,this.gobbleSpaces(),E=this.code}if(this.index++,E===R.OBRACK_CODE){if(y={type:R.MEMBER_EXP,computed:!0,object:y,property:this.gobbleExpression()},!y.property)this.throwError('Unexpected "'+this.char+'"');if(this.gobbleSpaces(),E=this.code,E!==R.CBRACK_CODE)this.throwError("Unclosed [");this.index++}else if(E===R.OPAREN_CODE)y={type:R.CALL_EXP,arguments:this.gobbleArguments(R.CPAREN_CODE),callee:y};else if(E===R.PERIOD_CODE||M){if(M)this.index--;this.gobbleSpaces(),y={type:R.MEMBER_EXP,computed:!1,object:y,property:this.gobbleIdentifier()}}if(M)y.optional=!0;this.gobbleSpaces(),E=this.code}return y}gobbleNumericLiteral(){let y="",E,M;while(R.isDecimalDigit(this.code))y+=this.expr.charAt(this.index++);if(this.code===R.PERIOD_CODE){y+=this.expr.charAt(this.index++);while(R.isDecimalDigit(this.code))y+=this.expr.charAt(this.index++)}if(E=this.char,E==="e"||E==="E"){if(y+=this.expr.charAt(this.index++),E=this.char,E==="+"||E==="-")y+=this.expr.charAt(this.index++);while(R.isDecimalDigit(this.code))y+=this.expr.charAt(this.index++);if(!R.isDecimalDigit(this.expr.charCodeAt(this.index-1)))this.throwError("Expected exponent ("+y+this.char+")")}if(M=this.code,R.isIdentifierStart(M))this.throwError("Variable names cannot start with a number ("+y+this.char+")");else if(M===R.PERIOD_CODE||y.length===1&&y.charCodeAt(0)===R.PERIOD_CODE)this.throwError("Unexpected period");return{type:R.LITERAL,value:parseFloat(y),raw:y}}gobbleStringLiteral(){let y="",E=this.index,M=this.expr.charAt(this.index++),z=!1;while(this.index<this.expr.length){let F=this.expr.charAt(this.index++);if(F===M){z=!0;break}else if(F==="\\")switch(F=this.expr.charAt(this.index++),F){case"n":y+=`
`;break;case"r":y+="\r";break;case"t":y+="\t";break;case"b":y+="\b";break;case"f":y+="\f";break;case"v":y+="\v";break;default:y+=F}else y+=F}if(!z)this.throwError('Unclosed quote after "'+y+'"');return{type:R.LITERAL,value:y,raw:this.expr.substring(E,this.index)}}gobbleIdentifier(){let y=this.code,E=this.index;if(R.isIdentifierStart(y))this.index++;else this.throwError("Unexpected "+this.char);while(this.index<this.expr.length)if(y=this.code,R.isIdentifierPart(y))this.index++;else break;return{type:R.IDENTIFIER,name:this.expr.slice(E,this.index)}}gobbleArguments(y){let E=[],M=!1,z=0;while(this.index<this.expr.length){this.gobbleSpaces();let F=this.code;if(F===y){if(M=!0,this.index++,y===R.CPAREN_CODE&&z&&z>=E.length)this.throwError("Unexpected token "+String.fromCharCode(y));break}else if(F===R.COMMA_CODE){if(this.index++,z++,z!==E.length){if(y===R.CPAREN_CODE)this.throwError("Unexpected token ,");else if(y===R.CBRACK_CODE)for(let G=E.length;G<z;G++)E.push(null)}}else if(E.length!==z&&z!==0)this.throwError("Expected comma");else{let G=this.gobbleExpression();if(!G||G.type===R.COMPOUND)this.throwError("Expected comma");E.push(G)}}if(!M)this.throwError("Expected "+String.fromCharCode(y));return E}gobbleGroup(){this.index++;let y=this.gobbleExpressions(R.CPAREN_CODE);if(this.code===R.CPAREN_CODE)if(this.index++,y.length===1)return y[0];else if(!y.length)return!1;else return{type:R.SEQUENCE_EXP,expressions:y};else this.throwError("Unclosed (")}gobbleArray(){return this.index++,{type:R.ARRAY_EXP,elements:this.gobbleArguments(R.CBRACK_CODE)}}}var U=new $;Object.assign(R,{hooks:U,plugins:new D(R),COMPOUND:"Compound",SEQUENCE_EXP:"SequenceExpression",IDENTIFIER:"Identifier",MEMBER_EXP:"MemberExpression",LITERAL:"Literal",THIS_EXP:"ThisExpression",CALL_EXP:"CallExpression",UNARY_EXP:"UnaryExpression",BINARY_EXP:"BinaryExpression",ARRAY_EXP:"ArrayExpression",TAB_CODE:9,LF_CODE:10,CR_CODE:13,SPACE_CODE:32,PERIOD_CODE:46,COMMA_CODE:44,SQUOTE_CODE:39,DQUOTE_CODE:34,OPAREN_CODE:40,CPAREN_CODE:41,OBRACK_CODE:91,CBRACK_CODE:93,QUMARK_CODE:63,SEMCOL_CODE:59,COLON_CODE:58,unary_ops:{"-":1,"!":1,"~":1,"+":1},binary_ops:{"||":1,"??":1,"&&":2,"|":3,"^":4,"&":5,"==":6,"!=":6,"===":6,"!==":6,"<":7,">":7,"<=":7,">=":7,"<<":8,">>":8,">>>":8,"+":9,"-":9,"*":10,"/":10,"%":10,"**":11},right_associative:new Set(["**"]),additional_identifier_chars:new Set(["$","_"]),literals:{true:!0,false:!1,null:null},this_str:"this"});R.max_unop_len=R.getMaxKeyLen(R.unary_ops);R.max_binop_len=R.getMaxKeyLen(R.binary_ops);var V=(y)=>new R(y).parse(),X=Object.getOwnPropertyNames(class{});Object.getOwnPropertyNames(R).filter((y)=>!X.includes(y)&&V[y]===void 0).forEach((y)=>{V[y]=R[y]});V.Jsep=R;var x="ConditionalExpression",H={name:"ternary",init(y){y.hooks.add("after-expression",function(M){if(M.node&&this.code===y.QUMARK_CODE){this.index++;let z=M.node,F=this.gobbleExpression();if(!F)this.throwError("Expected expression");if(this.gobbleSpaces(),this.code===y.COLON_CODE){this.index++;let G=this.gobbleExpression();if(!G)this.throwError("Expected expression");if(M.node={type:x,test:z,consequent:F,alternate:G},z.operator&&y.binary_ops[z.operator]<=0.9){let K=z;while(K.right.operator&&y.binary_ops[K.right.operator]<=0.9)K=K.right;M.node.test=K.right,K.right=M.node,M.node=z}}else this.throwError("Expected :")}})}};V.plugins.register(H);function Z(){return Z=Object.assign?Object.assign.bind():function(y){for(var E=1;E<arguments.length;E++){var M=arguments[E];for(var z in M)Object.prototype.hasOwnProperty.call(M,z)&&(y[z]=M[z])}return y},Z.apply(this,arguments)}class B{static addUnaryOp(y,E){V.addUnaryOp(y),B.unops[y]=E}static addBinaryOp(y,E,M,z){let F,G,K;typeof E=="function"?K=E:(F=E,typeof M=="function"?K=M:(G=M,K=z)),V.addBinaryOp(y,F||1,G),B.binops[y]=K}static addEvaluator(y,E){B.evaluators[y]=E}static registerPlugin(...y){y.forEach((E)=>{E.init&&B.parse.plugins.register(E),E.initEval&&E.initEval.call(B,B)})}static eval(y,E){return new B(E).eval(y)}static async evalAsync(y,E){return new B(E,!0).eval(y)}static compile(y){return B.eval.bind(null,B.jsep(y))}static compileAsync(y){return B.evalAsync.bind(null,B.jsep(y))}static evalExpr(y,E){return B.compile(y)(E)}static evalExprAsync(y,E){return B.compileAsync(y)(E)}constructor(y,E){this.context=void 0,this.isAsync=void 0,this.context=y,this.isAsync=E}eval(y,E=(M)=>M){let M=B.evaluators[y.type]||B.evaluators.default;if(!M)throw Error(`unknown node type: ${JSON.stringify(y,null,2)}`);return this.evalSyncAsync(M.bind(this)(y,this.context),(z)=>(y._value=z,E(z)))}evalSyncAsync(y,E){return this.isAsync?Promise.resolve(y).then(E):E(y)}evalArrayExpression(y){return this.evalArray(y.elements)}evalArray(y){let E=y.map((z)=>this.eval(z)),M=(z)=>z.reduce((F,G,K)=>y[K].type==="SpreadElement"?[...F,...G]:(F.push(G),F),[]);return this.isAsync?Promise.all(E).then(M):M(E)}evalBinaryExpression(y){if(y.operator==="||")return this.eval(y.left,(z)=>z||this.eval(y.right));if(y.operator==="&&")return this.eval(y.left,(z)=>z&&this.eval(y.right));let E=[this.eval(y.left),this.eval(y.right)],M=([z,F])=>B.binops[y.operator](z,F);return this.isAsync?Promise.all(E).then(M):M(E)}evalCompoundExpression(y){return this.isAsync?y.body.reduce((E,M)=>E.then(()=>this.eval(M)),Promise.resolve()):y.body.map((E)=>this.eval(E))[y.body.length-1]}evalCallExpression(y){return this.evalSyncAsync(this.evalCall(y.callee),([E,M])=>this.evalSyncAsync(this.evalArray(y.arguments),(z)=>E.apply(M===y.callee?this.context:M,z)))}evalCall(y){return y.type==="MemberExpression"?this.evalSyncAsync(this.evaluateMember(y),([E,M])=>B.validateFnAndCall(M,E,y)):this.eval(y,(E)=>B.validateFnAndCall(E,y))}evalConditionalExpression(y){return this.eval(y.test,(E)=>this.eval(E?y.consequent:y.alternate))}evalIdentifier(y){return this.context[y.name]}static evalLiteral(y){return y.value}evalMemberExpression(y){return this.evalSyncAsync(this.evaluateMember(y),([,E])=>E)}evaluateMember(y){return this.eval(y.object,(E)=>this.evalSyncAsync(y.computed?this.eval(y.property):y.property.name,(M)=>{if(/^__proto__|prototype|constructor$/.test(M))throw Error(`Access to member "${M}" disallowed.`);return[E,(y.optional?E||{}:E)[M],M]}))}evalThisExpression(){return this.context}evalUnaryExpression(y){return this.eval(y.argument,(E)=>B.unops[y.operator](E))}evalArrowFunctionExpression(y){return this.isAsync!==y.async?B[y.async?"evalAsync":"eval"](y,this.context):(...E)=>{let M=this.evalArrowContext(y,E);return B[y.async?"evalAsync":"eval"](y.body,M)}}evalArrowContext(y,E){let M=Z({},this.context);return(y.params||[]).forEach((z,F)=>{if(z.type==="AssignmentExpression"&&(E[F]===void 0&&(E[F]=this.eval(z.right)),z=z.left),z.type==="Identifier")M[z.name]=E[F];else if(z.type==="ArrayExpression")z.elements.forEach((G,K)=>{let Q=E[F][K];if(G.type==="AssignmentExpression"&&(Q===void 0&&(Q=this.eval(G.right)),G=G.left),G.type!=="Identifier")throw Error("Unexpected arrow function argument");M[G.name]=Q});else if(z.type==="ObjectExpression"){let G=[];z.properties.forEach((K)=>{let Q,S=K;if(S.type==="AssignmentExpression"&&(S=S.left),S.type==="Property")Q=S.key.type==="Identifier"?S.key.name:this.eval(S.key).toString();else if(S.type==="Identifier")Q=S.name;else{if(S.type!=="SpreadElement"||S.argument.type!=="Identifier")throw Error("Unexpected arrow function argument");Q=S.argument.name}let W=E[F][Q];S.type==="SpreadElement"?(W=Z({},E[F]),G.forEach((Y)=>{delete W[Y]})):W===void 0&&K.type==="AssignmentExpression"&&(W=this.eval(K.right)),M[Q]=W,G.push(Q)})}else{if(z.type!=="SpreadElement"||z.argument.type!=="Identifier")throw Error("Unexpected arrow function argument");M[z.argument.name]=E.slice(F)}}),M}evalAssignmentExpression(y){return this.evalSyncAsync(this.getContextAndKey(y.left),([E,M])=>this.eval(y.right,(z)=>B.assignOps[y.operator](E,M,z)))}evalUpdateExpression(y){return this.evalSyncAsync(this.getContextAndKey(y.argument),([E,M])=>B.evalUpdateOperation(y,E,M))}evalAwaitExpression(y){return B.evalAsync(y.argument,this.context)}static evalUpdateOperation(y,E,M){return y.prefix?y.operator==="++"?++E[M]:--E[M]:y.operator==="++"?E[M]++:E[M]--}getContextAndKey(y){if(y.type==="MemberExpression")return this.evalSyncAsync(this.evaluateMember(y),([E,,M])=>[E,M]);if(y.type==="Identifier")return[this.context,y.name];if(y.type==="ConditionalExpression")return this.eval(y.test,(E)=>this.getContextAndKey(E?y.consequent:y.alternate));throw Error("Invalid Member Key")}evalNewExpression(y){return this.evalSyncAsync(this.evalCall(y.callee),([E])=>this.evalSyncAsync(this.evalArray(y.arguments),(M)=>B.construct(E,M,y)))}evalObjectExpression(y){let E={},M=y.properties.map((z)=>{if(z.type==="SpreadElement")Object.assign(E,B.eval(z.argument,this.context));else if(z.type==="Property")return this.evalSyncAsync(z.key.type==="Identifier"?z.key.name:this.eval(z.key),(F)=>this.eval(z.shorthand?z.key:z.value,(G)=>{E[F]=G}))});return this.isAsync?Promise.all(M).then(()=>E):E}evalSpreadElement(y){return this.eval(y.argument)}evalTaggedTemplateExpression(y){let E=[this.evalCall(y.tag),this.evalSyncAsync(this.evalArray(y.quasi.expressions),(z)=>[y.quasi.quasis.map((F)=>F.value.cooked),...z])],M=([[z,F],G])=>z.apply(F,G);return this.isAsync?Promise.all(E).then(M):M(E)}evalTemplateLiteral(y){return this.evalSyncAsync(this.evalArray(y.expressions),(E)=>y.quasis.reduce((M,z,F)=>(M+=z.value.cooked,z.tail||(M+=E[F]),M),""))}static construct(y,E,M){try{return new(Function.prototype.bind.apply(y,[null].concat(E)))}catch(z){throw Error(`${B.nodeFunctionName(M.callee)} is not a constructor`)}}static validateFnAndCall(y,E,M){if(typeof y!="function"){if(!y&&M&&M.optional)return[()=>{},E];let z=B.nodeFunctionName(M||E);throw Error(`'${z}' is not a function`)}return[y,E]}static nodeFunctionName(y){return y&&(y.name||y.property&&y.property.name)}}B.jsep=V,B.parse=V,B.evaluate=B.eval,B.evaluators={ArrayExpression:B.prototype.evalArrayExpression,LogicalExpression:B.prototype.evalBinaryExpression,BinaryExpression:B.prototype.evalBinaryExpression,CallExpression:B.prototype.evalCallExpression,Compound:B.prototype.evalCompoundExpression,ConditionalExpression:B.prototype.evalConditionalExpression,Identifier:B.prototype.evalIdentifier,Literal:B.evalLiteral,OptionalMemberExpression:B.prototype.evalMemberExpression,MemberExpression:B.prototype.evalMemberExpression,ThisExpression:B.prototype.evalThisExpression,UnaryExpression:B.prototype.evalUnaryExpression,ArrowFunctionExpression:B.prototype.evalArrowFunctionExpression,AssignmentExpression:B.prototype.evalAssignmentExpression,UpdateExpression:B.prototype.evalUpdateExpression,AwaitExpression:B.prototype.evalAwaitExpression,NewExpression:B.prototype.evalNewExpression,ObjectExpression:B.prototype.evalObjectExpression,SpreadElement:B.prototype.evalSpreadElement,TaggedTemplateExpression:B.prototype.evalTaggedTemplateExpression,TemplateLiteral:B.prototype.evalTemplateLiteral},B.DEFAULT_PRECEDENCE={"||":1,"&&":2,"|":3,"^":4,"&":5,"==":6,"!=":6,"===":6,"!==":6,"<":7,">":7,"<=":7,">=":7,"<<":8,">>":8,">>>":8,"+":9,"-":9,"*":10,"/":10,"%":10},B.binops={"||":function(y,E){return y||E},"&&":function(y,E){return y&&E},"|":function(y,E){return y|E},"^":function(y,E){return y^E},"&":function(y,E){return y&E},"==":function(y,E){return y==E},"!=":function(y,E){return y!=E},"===":function(y,E){return y===E},"!==":function(y,E){return y!==E},"<":function(y,E){return y<E},">":function(y,E){return y>E},"<=":function(y,E){return y<=E},">=":function(y,E){return y>=E},"<<":function(y,E){return y<<E},">>":function(y,E){return y>>E},">>>":function(y,E){return y>>>E},"+":function(y,E){return y+E},"-":function(y,E){return y-E},"*":function(y,E){return y*E},"/":function(y,E){return y/E},"%":function(y,E){return y%E}},B.unops={"-":function(y){return-y},"+":function(y){return+y},"~":function(y){return~y},"!":function(y){return!y}},B.assignOps={"=":function(y,E,M){return y[E]=M},"*=":function(y,E,M){return y[E]*=M},"**=":function(y,E,M){return y[E]**=M},"/=":function(y,E,M){return y[E]/=M},"%=":function(y,E,M){return y[E]%=M},"+=":function(y,E,M){return y[E]+=M},"-=":function(y,E,M){return y[E]-=M},"<<=":function(y,E,M){return y[E]<<=M},">>=":function(y,E,M){return y[E]>>=M},">>>=":function(y,E,M){return y[E]>>>=M},"&=":function(y,E,M){return y[E]&=M},"^=":function(y,E,M){return y[E]^=M},"|=":function(y,E,M){return y[E]|=M}};var{DEFAULT_PRECEDENCE:O,evaluators:q,binops:A,unops:I,assignOps:w,addUnaryOp:T,addBinaryOp:C,addEvaluator:f,registerPlugin:j,eval:k,evalAsync:g,compile:P,compileAsync:v,evalExpr:b,evalExprAsync:u}=B;function l(y,E){return{compiled:P(y),token:E}}export{l as parseExpression};
